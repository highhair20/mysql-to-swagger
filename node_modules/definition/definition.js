"use strict";

var assign = require('lodash').assign;
var partial = require('lodash').partial;

function definition(opts, proto)
{
	if (proto == null) {
		proto = opts;
		opts = assign({}, definition._defaults);
	} else if (opts != null) {
		opts = assign({}, definition._defaults, opts);
	} else {
		opts = assign({}, definition._defaults);
	}

	proto = assign({}, proto);

	var Constructor;

	if (exists(proto, 'constructor')) {
		Constructor = proto.constructor;
	} else {
		Constructor = function Constructor() {};
	}

	if (exists(opts, 'extends')) {
		Constructor.prototype = Object.create(opts.extends.prototype);
		Constructor.prototype.constructor = Constructor;
		if (opts.addSuper) {
			Constructor.prototype._super = partial(_super, opts.extends);
			Constructor.prototype._superApply = partial(_superApply, opts.extends);
		}
	}

	var accessors = {};

	for (var key in proto) if (key !== 'constructor' && proto.hasOwnProperty(key)) {
		first(
			{
				Constructor: Constructor,
				opts: opts,
				key: key,
				value: proto[key],
				proto: proto,
				accessors: accessors
			},
			defineGetSet,
			defineProperty
		);
	}

	return Constructor;
}
module.exports = definition;

definition._defaults = {
	extends: null,
	makeAccessor: true,
	makeStatic: true,
	methodOnly: true,
	addSuper: true
};

function _super(parent, name)
{
	/* jshint validthis: true */
	return parent.prototype[name].apply(this, Array.prototype.slice.call(arguments, 2));
}

function _superApply(parent, name, args)
{
	/* jshint validthis: true */
	return parent.prototype[name].apply(this, args);
}

function exists(obj, key)
{
	return obj.hasOwnProperty(key) && obj[key] != null;
}

function isFunction(value)
{
	return (value instanceof Function);
}

function first(desc)
{
	for (var i = 1, max = arguments.length; i < max; ++i) {
		if (arguments[i](desc)) {
			break;
		}
	}
}

function defineGetSet(desc)
{
	if (!(desc.value instanceof Function)) {
		return false;
	} else if (!desc.opts.makeAccessor) {
		return false;
	}

	var match = desc.key.match(/^(?:(static) )?(?:get|set) ([\s\S]+?)$/);

	if (!match) {
		return false;
	}

	var isStatic = !!match[1];
	var name = match[2];
	var key = isStatic ? 'static ' + name : name;
	var def = {
		configurable: true,
		enumerable: true
	};
	var getter;
	var setter;

	if (desc.accessors.hasOwnProperty(key)) {
		// The accessor has already been created.
		return true;
	} else if (desc.proto.hasOwnProperty(key)) {
		throw new Error("accessor duplicates '" + key + "'");
	}

	desc.accessors[key] = true;

	if (isStatic) {
		getter = 'static get ' + name;
		setter = 'static set ' + name;
	} else {
		getter = 'get ' + name;
		setter = 'set ' + name;
	}

	if (desc.proto.hasOwnProperty(getter) && isFunction(desc.proto[getter])) {
		def.get = desc.proto[getter];
	}

	if (desc.proto.hasOwnProperty(setter) && isFunction(desc.proto[setter])) {
		def.set = desc.proto[setter];
	}

	if (isStatic && !desc.opts.makeStatic) {
		isStatic = false;
		name = key;
	}

	Object.defineProperty(isStatic ? desc.Constructor : desc.Constructor.prototype, name, def);

	return true;
}

function defineProperty(desc)
{
	if (desc.opts.methodOnly && !(desc.value instanceof Function)) {
		throw new Error("only properties of type Function are allowed");
	}

	var match = desc.key.match(/^(?:(static) )?([\s\S]+?)$/);

	if (!match) {
		return false;
	}

	var isStatic = !!match[1];
	var name = match[2];
	
	if (isStatic && !desc.opts.makeStatic) {
		isStatic = false;
		name = desc.key;
	}

	(isStatic ? desc.Constructor : desc.Constructor.prototype)[name] = desc.value;

	return true;
}