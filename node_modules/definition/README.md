definition
==========

Class definition helper which closely maps to ES6 classes.

This utility is meant to fill the gap until ES6 is finalized. If you can, write
ES6 JavaScript and compile it back to ES5 using something like esnext. But if
that's not an option in your project, then this utility can keep your class
definitions clean and allow easy conversion to ES6 syntax later.

Usage
-----

```js
definition([options], properties) -> Function
```

### Options
* `extends`
	* Default null
	* A parent class constructor to inherit from.
	* Equivalent to the ES6 `class Name extends Parent` syntax.
* `addSuper`
	* Default true
	* Add _super and _superApply if the `extends` option is set.
	* Equivalent to the ES6 `super()` function.
* `methodOnly`
	* Default true
	* Throw an error if the properties object contains a value that is not an
	instance of Function.
	* Equivalent to the ES6 `class` syntax which only allows methods.
* `makeAccessor`
	* Default true
	* Use method names prefixed with "get " or "set " to define getter/setter
	object properties.
	* Equivalent to the ES6 `get` and `set` class method definition keywords.
* `makeStatic`
	* Default true
	* Use names prefixed with "static " to define static object properties.
	* Equivalent to the ES6 `static` class method definition keyword.

### Example

```js
var definition = require('definition');

// Simple class definition.
var MyClass = definition({
	constructor: function(arg)
	{

	},
	method: function()
	{

	}
});

// Extended class definition. Pass the parent constructor as the `extends`
// option to create a class that inherits from it.
var DerivedClass = definition({ extends: MyClass }, {

	// _super and _superApply methods are added automatically when the extends
	// option is set, unless the `addSuper` option is set to false.
	constructor: function()
	{
		this._super('constructor', 'arg');
	},
	method: function()
	{
		return this._superApply('method', arguments);
	},

	// "set foo" and "get foo" will get combined into a accessor property "foo".
	// This behavior can be disabled by setting the `makeAccessor` option to
	// false.
	"set foo": function(value)
	{

	},
	"get foo": function()
	{

	},

	// Creates a property "bar" attached to the constructor. It can be accessed
	// via `DerivedClass.bar`, NOT `this.bar`. If the `makeStatic` option is
	// false, then the "static " prefix becomes part of the name of an instance
	// property.
	"static bar": function()
	{

	},

	// "static set baz" and "static get baz" will get combined into a accessor
	// property "baz" attached to the constructor. It can be accessed via
	// `DerivedClass.baz`, NOT `this.baz`. If the `makeStatic` option is false,
	// then the "static " prefix becomes part of the name of an instance
	// accessor.
	"static set baz": function(value)
	{

	},
	"static get baz": function()
	{

	},

	// This will throw an exception because only class methods can be defined.
	// Initialize class value properties in the constructor instead. You can
	// allow value definition here by setting the `methodOnly` option to false.
	value: true
});
```