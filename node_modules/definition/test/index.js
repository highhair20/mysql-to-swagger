"use strict";

/* jshint mocha: true */

var expect = require('chai').expect;
var def = require('../');

describe("#definition([options], [methods])", function()
{
	it("should return a constructor with a blank prototype when passed no parameters", function()
	{
		var A = def();

		expect(A).to.be.an.instanceof(Function);
		expect(A.prototype).to.deep.equal({});
	});

	it("should return the explicit constructor method", function()
	{
		var constructor = function() {};
		var constructor2 = function() {};

		var A = def({
			constructor: constructor
		});

		expect(A).to.equal(constructor);

		var B = def({ extends: A }, {
			constructor: constructor2
		});

		expect(B).to.equal(constructor2);
	});

	it("should throw an error if the methods object contains a non-function value", function()
	{
		expect(def.bind(this, { a: true })).to.throw(Error);
	});

	it("should not throw an error if the methods object contains a non-function value and the `methodOnly` option is false", function()
	{
		expect(def.bind(this, { methodOnly: false }, { a: true })).to.not.throw(Error);
	});

	describe("instance", function() {
		it("should extend the parent class if the `extends` option is set", function()
		{
			function Parent() {}

			var Child = def({ extends: Parent }, {});
			var child = new Child();

			expect(child).to.be.an.instanceof(Parent);
		});

		it("should automatically add _super and _superApply methods when extending a parent class", function()
		{
			function Parent() {}

			var Child = def({ extends: Parent }, {});
			var child = new Child();

			expect(child._super).to.be.an.instanceof(Function);
			expect(child._superApply).to.be.an.instanceof(Function);
		});
		
		it("should not add _super and _superApply methods when extending a parent class if the `addSuper` option is false", function()
		{
			function Parent() {}

			var Child = def({ extends: Parent, addSuper: false }, {});
			var child = new Child();

			expect(child._super).to.not.exist();
			expect(child._superApply).to.not.exist();
		});

		it("should call the parent's method when invoked with _super", function()
		{
			var called = false;

			function Parent() {}
			Parent.prototype.a = function(value) {
				expect(value).to.equal('value');
				called = true;
			};

			var Child = def({ extends: Parent }, {
				a: function()
				{
					this._super('a', 'value');
				}
			});

			var child = new Child();

			child.a();

			expect(called).to.be.true();
		});

		it("should call the parent's method when invoked with _superApply", function()
		{
			var called = false;

			function Parent() {}
			Parent.prototype.a = function(value) {
				expect(value).to.equal('value');
				called = true;
			};

			var Child = def({ extends: Parent }, {
				a: function()
				{
					this._superApply('a', ['value']);
				}
			});

			var child = new Child();

			child.a();

			expect(called).to.be.true();
		});

		it("should attach all methods to the returned constructor's prototype", function()
		{
			var constructor = function() {};
			var a = function() {};

			var A = def({
				constructor: constructor,
				a: a
			});

			expect(A.prototype.constructor).to.equal(constructor);
			expect(A.prototype.a).to.equal(a);

			var B = def({}, {
				constructor: constructor,
				a: a
			});

			expect(B.prototype.constructor).to.equal(constructor);
			expect(B.prototype.a).to.equal(a);
		});

		it("should create a read only accessor property `value` from a method named `get value`", function()
		{
			var A = def({
				"get value": function() { return 'a'; }
			});

			var a = new A();

			expect(a.value).to.equal('a');
			expect(function()
			{
				a.value = 'b';
			}).to.throw(Error);
		});

		it("should create a write only accessor property `value` from a method named `set value`", function()
		{
			var A = def({
				"set value": function() {}
			});

			var a = new A();

			expect(function()
			{
				a.value = 'b';
			}).to.not.throw(Error);

			expect(a.value).to.be.undefined();
		});

		it("should create a read/write accessor property `value` from `get value` and `set value` methods", function()
		{
			var value = 'a';

			var A = def({
				"get value": function() { return value; },
				"set value": function(val) { value = val; }
			});

			var a = new A();

			expect(a.value).to.equal('a');

			expect(function()
			{
				a.value = 'b';
			}).to.not.throw(Error);

			expect(a.value).to.equal('b');
		});

		it("should not create accessors from `get ` and `set ` prefixed method names if the `makeAccessor` option is false.", function()
		{
			function get_value() {}
			function set_value() {}

			var A = def({ makeAccessor: false }, {
				"get value": get_value,
				"set value": set_value
			});

			var a = new A();

			expect(a["get value"]).to.equal(get_value);
			expect(a["set value"]).to.equal(set_value);
		});
	});

	describe("static", function() {
		it("should attach all static methods to the returned constructor", function()
		{
			var a = function() {};
			var b = function() {};

			var A = def({
				"static a": a,
				"static b": b
			});

			expect(A.a).to.equal(a);
			expect(A.b).to.equal(b);
			expect(A.prototype.a).to.be.undefined();
			expect(A.prototype.b).to.be.undefined();
			expect(A.prototype["static a"]).to.be.undefined();
			expect(A.prototype["static b"]).to.be.undefined();
		});

		it("should create a read only static accessor property `value` from a method named `static get value`", function()
		{
			var A = def({
				"static get value": function() { return 'a'; }
			});

			expect(A.value).to.equal('a');
			expect(function()
			{
				A.value = 'b';
			}).to.throw(Error);
		});

		it("should create a write only static accessor property `value` from a method named `static set value`", function()
		{
			var A = def({
				"static set value": function() {}
			});

			expect(function()
			{
				A.value = 'b';
			}).to.not.throw(Error);

			expect(A.value).to.be.undefined();
		});

		it("should create a read/write static accessor property `value` from `static get value` and `static set value` methods", function()
		{
			var value = 'a';

			var A = def({
				"static get value": function() { return value; },
				"static set value": function(val) { value = val; }
			});

			expect(A.value).to.equal('a');

			expect(function()
			{
				A.value = 'b';
			}).to.not.throw(Error);

			expect(A.value).to.equal('b');
		});

		it("should treat the 'static ' prefix as part of the instance property name if the `makeStatic` option is false.", function()
		{
			var a = function() {};
			var b = function() {};

			var A = def({ makeStatic: false }, {
				"static a": a,
				"static b": b
			});

			expect(A.a).to.be.undefined();
			expect(A.b).to.be.undefined();
			expect(A.prototype.a).to.be.undefined();
			expect(A.prototype.b).to.be.undefined();
			expect(A.prototype["static a"]).to.equal(a);
			expect(A.prototype["static b"]).to.equal(b);
		});
	});
});